<!DOCTYPE html>
<html prefix="" lang="pt_br">
<head>
<meta charset="utf-8">
<meta name="description" content="Uma pequena ajuda mais prática que técnica ou teórica para quem está aprendendo sobre NLP">
<meta name="viewport" content="width=device-width">
<title>Anotações sobre NLP</title>
<link href="assets/css/rst.css" rel="stylesheet" type="text/css">
<link href="assets/css/code.css" rel="stylesheet" type="text/css">
<link href="assets/css/dark.css" rel="stylesheet" type="text/css">
<link href="assets/css/theme.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Share+Tech+Mono" rel="stylesheet">
<link href="assets/css/ipython.min.css" rel="stylesheet" type="text/css">
<link href="assets/css/nikola_ipython.css" rel="stylesheet" type="text/css">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
<link rel="canonical" href="http://demacdolincoln.github.io/anotacoes-nlp/posts/">
<link rel="next" href="index-1.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]--><script src="https://cdn.jsdelivr.net/npm/vega@4.4.0"></script><script src="https://cdn.jsdelivr.net/npm/vega-lite@2.6.0"></script><script src="https://cdn.jsdelivr.net/npm/vega-embed@3.24.2"></script><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/highlight.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/languages/python.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.5/languages/julia.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script><link rel="prefetch" href="posts/resumos-0-pagerank/" type="text/html">
</head>
<body class="hack dark">

<a href="#content" class="sr-only sr-only-focusable">Pular para o conteúdo principal</a>
    <div id="container">
         
    <header id="header"><h1 id="brand"><a href="http://demacdolincoln.github.io/anotacoes-nlp/posts/" title="Anotações sobre NLP" rel="home">

        <span id="blog-title">Anotações sobre NLP</span>
    </a></h1>

        

        
    <nav id="menu"><ul>
<li><a href="archive.html">Arquivo</a></li>
                <li><a href="categories/">Etiqueta</a></li>
                <li><a href="rss.xml">Feed RSS</a></li>

    

    
    
    </ul></nav></header><main id="content"><div class="postindex">
    <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/resumos-0-pagerank/" class="u-url">Resumos 0: PageRank</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Lincoln de Macêdo
            </span></p>
            <p class="dateline">
            <a href="posts/resumos-0-pagerank/" rel="bookmark">
            <time class="published dt-published" datetime="2018-12-25T13:31:18-03:00" itemprop="datePublished" title="2018-12-25 13:31">2018-12-25 13:31</time></a>
            </p>
                <p class="commentline">
        
    <a href="posts/resumos-0-pagerank/#disqus_thread" data-disqus-identifier="cache/posts/resumos-0-pagerank.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>Esta é uma anotação introdutória ao problema de resumir textos, o ponto principal abordado aqui será a dificuldade de identificar o que é relevante, para isso usei o textrank, não entrarei em muitos detalhes sobre esse algoritmo, tratando de forma intuitiva a idéia geral que será mais aprofundada em anotações posteriores.</p>
<p>PageRank foi o primeiro algoritmo usado pelo google para rankear os links de sua busca, logicamente o google evoluiu neste tempo todo e usa uma combinação de vários algoritmos e não o pagerank puro, aqui o usaremos para rankear os parágrafos de um texto da wikipedia.</p>
<div class="section" id="funcionamento">
<h2>Funcionamento</h2>
<p>Não entrarei em muitos detalhes sobre o algoritmo, então explicando de forma superficial temos o fato do pagerank se valer de um grafo, e ao considerar o grau de cada nó, ou seja a quantidade de conexões de cada nó, e um peso atribuído a cada conexão, teremos um ranking de importância. Até mesmo explicando desse modo já imaginamos como o algoritmo se aplica bem a links entre páginas na internet, mas para textos ele realmente não é tão adequado porém é didático como algo introdutório.</p>
<p>Os passos do "resumo" que na verdade é um rankeamento:</p>
<ol class="arabic simple">
<li>extrair estatísticas do texto (<a class="reference external" href="posts/estatistica-tf-idf-e-lsa">tf-idf</a> ou <a class="reference external" href="posts/word2vec-1-introducao">word2vec</a>, enfim, qualquer coisa que nos diga algo sobre o texto)</li>
<li>gerar uma matriz de similaridade, que na verdade servirá como matriz adjacente</li>
<li>converter a matriz adjacente num grafo</li>
<li>aplicar o PageRank</li>
</ol>
</div>
<div class="section" id="implementacao">
<h2>Implementação</h2>
<p>Resolvi o skip-gram já treinado[1]_ e a página da wikipédia sobre Alan Turing como já feito antes, o processamento realmente começa criando listas com os valores correspondentes a cada palavra indicado pelo skip-gram.</p>
<pre class="code python"><a name="rest_code_7f655bc01807478aaf8481b70fbbbc42-1"></a><span class="n">sentences</span> <span class="o">=</span> <span class="p">[]</span>
<a name="rest_code_7f655bc01807478aaf8481b70fbbbc42-2"></a>
<a name="rest_code_7f655bc01807478aaf8481b70fbbbc42-3"></a><span class="k">for</span> <span class="n">paragraph</span> <span class="ow">in</span> <span class="n">text</span><span class="p">:</span>
<a name="rest_code_7f655bc01807478aaf8481b70fbbbc42-4"></a><span class="n">sentences</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">word2id</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">paragraph</span> <span class="k">if</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">id2word</span><span class="p">])</span>
</pre>
<p>O passo seguinte é criar uma matriz quadrada onde cada lado tem o nº de parágrafos, preenchi a matriz da seguinte forma:</p>
<pre class="code python"><a name="rest_code_d8741e6eb8c448659e1aecdaddf604bc-1"></a><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sentences</span><span class="p">):</span>
<a name="rest_code_d8741e6eb8c448659e1aecdaddf604bc-2"></a>    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sentences</span><span class="p">):</span>
<a name="rest_code_d8741e6eb8c448659e1aecdaddf604bc-3"></a>        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">j</span> <span class="p">:</span>
<a name="rest_code_d8741e6eb8c448659e1aecdaddf604bc-4"></a>            <span class="n">similarity_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
<a name="rest_code_d8741e6eb8c448659e1aecdaddf604bc-5"></a>                                          <span class="n">cosine_similarity</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">x</span><span class="p">],</span><span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">])</span>
<a name="rest_code_d8741e6eb8c448659e1aecdaddf604bc-6"></a>                                      <span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre>
<p>O que é feito acima é apenas comparar a similaridade de cossenos entre cada parágrafo, indicando de alguma forma algum nível de similaridade, de modo que o parágrafo com maior <strong>índice de similaridade</strong> em relação aos demais será aquele que melhor representa o conjunto.</p>
<img alt="/images/similarity_matrix-classificacao-1.png" src="images/similarity_matrix-classificacao-1.png"><p>Essa é uma matriz simétrica que seŕá lida como uma matriz adjacente de um grafo, cada linha e coluna serão nós e cada corrdenada indica o peso do vértice que liga cada nó, um dos problemas dessa estratégia é que todos os nós terão o mesmo grau, já que todos se ligam a todos, isso acaba inutilizando o uso do grau de cada nó para o pagerank, tendo como único parâmetro a considerar o peso dos vértices.</p>
<pre class="code python"><a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-1"></a><span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">from_numpy_array</span><span class="p">(</span><span class="n">similarity_matrix</span><span class="p">)</span>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-2"></a><span class="n">scores</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-3"></a>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-4"></a><span class="n">original</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-5"></a>    <span class="nb">open</span><span class="p">(</span><span class="s2">"original_text-Alan_Turing.pickle"</span><span class="p">,</span> <span class="s2">"rb"</span><span class="p">)</span>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-6"></a>    <span class="p">)</span>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-7"></a>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-8"></a>    <span class="n">word_rank</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-9"></a>            <span class="p">[(</span><span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">original</span><span class="p">)],</span>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-10"></a>            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-11"></a>            <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-12"></a>    <span class="p">)</span>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-13"></a>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-14"></a>    <span class="n">qnt_lines</span> <span class="o">=</span> <span class="mi">3</span>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-15"></a>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-16"></a>    <span class="n">top</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">word_rank</span><span class="p">[:</span><span class="n">qnt_lines</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-17"></a>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-18"></a>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">qnt_lines</span><span class="p">):</span>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-19"></a>        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"-- parágrafo do resumo: {i} | parágrafo original: {top[i][1]}"</span><span class="p">)</span>
<a name="rest_code_987e3760b0b646bb83d961a7d99e45cd-20"></a>        <span class="k">print</span><span class="p">(</span><span class="n">top</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">end</span><span class="o">=</span><span class="s2">"</span><span class="se">\n\n</span><span class="s2">"</span><span class="p">)</span>
</pre>
<p>Na saída do código acima podemos reparar que a ordem de importância dada a cada parágrafo não necessariamente está relacionado ao seu tamanho ou à sua posição no texto:
.. epigraph:</p>
<pre class="literal-block">
-- parágrafo do resumo: 0 | parágrafo original: 19
Por muitos anos, foram feitas campanhas que envolveram ativistas da tecnologia da informação, do meio político e do público LGBT. Em 11 de setembro de 2009, 55 anos após sua morte, o primeiro-ministro do Reino Unido, Gordon Brown, seguindo um pedido feito através de uma petição direcionada ao governo britânico, pediu desculpas formais em nome do governo pelo tratamento preconceituoso e desumano dado a Turing, que o levou ao suicídio. Em 24 de dezembro de 2013, passou a ter efeito a Real Prerrogativa do Perdão, concedida a Turing pela Rainha Elizabeth II, a pedido do ministro da justiça do Reino Unido, Chirs Grayling, depois que uma petição criada em 2012 obteve mais de 37.000 assinaturas solicitando o devido perdão.

-- parágrafo do resumo: 1 | parágrafo original: 3
A homossexualidade de Turing resultou em um processo criminal em 1952, pois atos homossexuais eram ilegais no Reino Unido na época, e ele aceitou o tratamento com hormônios femininos e castração química, como alternativa à prisão. Morreu em 1954, algumas semanas antes de seu aniversário de 42 anos, devido a um aparente autoadministrado envenenamento por cianeto, apesar de sua mãe (e alguns outros) terem considerado sua morte acidental. Em 10 de setembro de 2009, após uma campanha de internet, o primeiro-ministro britânico Gordon Brown fez um pedido oficial de desculpas público, em nome do governo britânico, devido à maneira pela qual Turing foi tratado após a guerra. Em 24 de dezembro de 2013, Alan Turing recebeu o perdão real da rainha Elizabeth II, da condenação por homossexualidade.

-- parágrafo do resumo: 2 | parágrafo original: 12
Em 1938, Turing se uniu ao GC&amp;CS, o braço de decodificação de mensagens da inteligência britânica, para efetuar a Criptoanálise da Máquina Enigma. O Enigma era uma máquina de codificação que mudava seus códigos diariamente, obrigando a que o projeto de decifração se tornasse bastante rápido. Após o Reino Unido iniciar a Segunda Guerra Mundial ao declarar guerra à Alemanha em 1939, Turing foi direcionado para o quartel da GC&amp;CS em Bletchley Park. A partir de uma máquina decodificadora polonesa, Turing projetou a Bomba eletromecânica ("Bombe"),  um equipamento eletromecânico que ajudaria a decriptar as mensagens do Enigma e foi montada em 1940. Novas Bombas foram construídas após Turing e sua equipe pedirem apoio a Winston Churchill, e mais de duzentas operavam ao fim da Guerra em 1945. Turing também introduziu sua equipe em Bletchley Park ao matemático Tommy Flowers, que em 1943 projetou o Colossus, um computador primitivo que ajudou a decodificar outra máquina criptográfica alemã, o Lorenz.
</pre>
<p>Logicamente eu poderia ter usado frases em vez de parágrafos para fazer o resumo, talvez até fizesse mais sentido chamar a saída do código de resumo, mas resolvi usar parágrafos inteiros por considerar que a idéia fica mais clara assim e ao comparar com o texto original, fica mais visualmente evidente como se deu o trabalho do pagerank, nos próximos posts sobre este tópico serão mostradas redes neurais que fazem um trabalho bem mais coerente, logicamente usarei redes neurais recorrentes e o seq2seq, portanto recomendo que veja as anotações que escrevi sobre esses temas:</p>
<p><a class="reference external" href="posts/gru-e-lstm">GRU e LSTM</a>
<a class="reference external" href="posts/seq2seq-introducao">seq2seq: introdução</a></p>
<p>---</p>
<p>_[1] <a class="reference external" href="http://www.nilc.icmc.usp.br/nilc/index.php/repositorio-de-word-embeddings-do-nilc">http://www.nilc.icmc.usp.br/nilc/index.php/repositorio-de-word-embeddings-do-nilc</a></p>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/classificacao-2-cnn/" class="u-url">Classificação 2: CNN</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Lincoln de Macêdo
            </span></p>
            <p class="dateline">
            <a href="posts/classificacao-2-cnn/" rel="bookmark">
            <time class="published dt-published" datetime="2018-12-25T05:17:55-03:00" itemprop="datePublished" title="2018-12-25 05:17">2018-12-25 05:17</time></a>
            </p>
                <p class="commentline">
        
    <a href="posts/classificacao-2-cnn/#disqus_thread" data-disqus-identifier="cache/posts/classificacao-2-cnn.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>Como falado <cite>anteriormente &lt;link://filename/posts/classificacao-1.rst&gt;_</cite>, classificar um texto é algo que vai além do vocabulário ainda que a gente utilize o word2vec ou o glove, e como a ordem das palavras importa muito, vamos dar aqui o 1º passo neste sentido, vamos ver como funciona uma rede neural convolucional (CNN) aplicada à classificação de textos.</p>
<p>Habitualmente elas são usadas essencialmente em processamento de imagens, a idéia é bastante simples: ter uma matriz maior e calcular uma matriz menor equivalente, neste processo há perda de dados e portanto é irreversível, porém tem se demonstrado muito útil em muitos casos.</p>
<div class="section" id="implementacao">
<h2>Implementação:</h2>
<p>O primeiro passo é transformar um texto numa matriz, para isso vamos recordar o que temos:</p>
<ul class="simple">
<li>texto ~&gt; sequência de ids de palavras</li>
<li>skip-gram, cbow, glove, etc. ~&gt; representação cartesiana de palavras segundo o sentido compreendido pelo seu uso</li>
</ul>
<p>Diante disso se torna meio lógico fazer uma matriz no formato <cite>words x embedding dims</cite>.</p>
<p>Um dos problemas dessa abordagem é que frases tem tamanhos variáveis enquanto a matriz de entrada na camada convolucional da CNN precisa ter tamanho fixo, então temos de lidar sempre com o pior caso, frases grandes, e preencher o espaço restante das frases menores com zeros, isso acaba nos obrigando ter um custo computacional extra já que teremos muitos espaços em branco só para que sempre tenhamos matrizes do mesmo tamanho.</p>
<p>---</p>
</div>
<div class="section" id="leituras-recomendadas">
<h2>Leituras recomendadas:</h2>
<p><a class="reference external" href="https://arxiv.org/abs/1408.5882">https://arxiv.org/abs/1408.5882</a></p>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/gru-e-lstm/" class="u-url">GRU e LSTM</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Lincoln de Macêdo
            </span></p>
            <p class="dateline">
            <a href="posts/gru-e-lstm/" rel="bookmark">
            <time class="published dt-published" datetime="2018-12-24T02:13:54-03:00" itemprop="datePublished" title="2018-12-24 02:13">2018-12-24 02:13</time></a>
            </p>
                <p class="commentline">
        
    <a href="posts/gru-e-lstm/#disqus_thread" data-disqus-identifier="cache/posts/gru-e-lstm.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>obs: Não vou me demorar tratando de questões teóricas sobre as RNN em si, já que o foco dessas anotações é NLP, futuramente, ao concluir essas anotações talvez eu inicie uma série mais abrangente sobre machine learning, mas por enquanto apenas traterei de assuntos teóricos relativos a NLP e ao resto apenas uma abordagem prática.</p>
<p>Parece meio óbvio dizer mas o que define uma rede neural recorrente é exatamente a recorrência, isto é, informações que são armazenadas e depois reutilizadas, a forma mais simples de implementação consiste em criar uma camada (um array) que armazena os resultados e é utilizado normalmente no processamento dos dados que passam por uma rede neural, só que com 1 caracérística distinta: haver uma condição ou não para atualizar esses dados aprendidos ao longo do treinamento e uma condição que a informação armazenada seja utilizada.</p>
<p>Devido a esse mecanismo ser claramente um gerenciamento de memória e estarmos tratando de redes neurais, não demora muito para começarmos a associar ao modo como nosso cérebro gerencia a memória, desta forma vem ao mundo em 1997 o LSTM (Long Short-Term Memory) <a class="footnote-reference" href="posts/gru-e-lstm/#id4" id="id1">[1]</a> <a class="footnote-reference" href="posts/gru-e-lstm/#id5" id="id2">[2]</a>, e como o nome bem indica, se trata de gerenciamento de memória de curto e longo prazo, posteriormente, em 2014 nasce o GRU (Gated Recurrent Unit) <a class="footnote-reference" href="posts/gru-e-lstm/#id6" id="id3">[3]</a>, mantendo diversas semelhanças com o LSTM porém com um custo computacional um pouco menor mas que no geral tem um desempenho semelhante ainda que é comum encontrar artigos falando que um ou outro método funcionou bem melhor em algum caso específico. Mas aqui estamos tratando de entender por alto como funciona esse gerenciamento de memória, o que precisamos ter noção é de como eles fazem isso?</p>
<div class="section" id="portoes">
<h2>Portões</h2>
<p>Portões == funções</p>
<img alt="https://upload.wikimedia.org/wikipedia/commons/3/3b/The_LSTM_cell.png" src="https://upload.wikimedia.org/wikipedia/commons/3/3b/The_LSTM_cell.png"><object data="https://upload.wikimedia.org/wikipedia/commons/3/37/Gated_Recurrent_Unit%2C_base_type.svg" type="image/svg+xml">
https://upload.wikimedia.org/wikipedia/commons/3/37/Gated_Recurrent_Unit%2C_base_type.svg</object>
<p>Explicando as imagens acima: a primeira mostra como funciona o LSTM e a segunda mostra como funciona o GRU, ainda que os diagramas sejam diferentes, vemos que as funções usadas, os "portões" são os mesmos embora aplicados de diferentes formas, como são as funções que importam para entender aidéia geral, vou direto à explicação sobre as funções.</p>
<div class="math">
\begin{equation*}
\sigma = \frac{1}{1 + exp(-x)}
\end{equation*}
</div>
<div class="math">
\begin{equation*}
tanh = \frac{e^x - e^-x}{e^x + e^{-x}}
\end{equation*}
</div>
<img alt="/images/lstm_gru-tanh-sigmoid.png" src="images/lstm_gru-tanh-sigmoid.png"><p>Vemos que a diferença entre os gráficos dessas funções é essencialmente o limite quando tende a menos infinito, e isso faz toda a diferença, pois um limite que tende a 0 significa que posteriormente qualquer número multiplicado por 0 será 0, neste caso a função sigmoide indica a relevância de cada dimensão de entrada, se a dimensão for próxima a zero, ela vai perdendo relevância até desaparecer ou ser substituída por outra informação mais relevante (decidida pela função tanh).</p>
<p>Todo o mecanismo de preservação e esquecimento desses métodos se baseia nesses "portões" que é como são chamadas as camadas com a função sigmoide, enquanto a função tanh tem o dever de fazer as escolhas finais, repare nas somas e multiplicações que unem o fluxo da saída com a camada oculta que armazena a memória, como a última estapa das operações com o estado da célula é sempre uma soma e os anteriores são multiplicações, isso revela a alteração dos pesos para definir a importância de cada dimensão e posteriormente a atualização mantendo assim para a época atual do treinamento da rede neural, a memória de curto prazo (os espaços próximos a zero que após a soma se mantém próximos aos resultados mais recentes) e a memória de longo prazo (o conteúdo mais relevante deixado mais próximo de 1)</p>
<p>---</p>
</div>
<div class="section" id="artigos-e-links-recomendados">
<h2>artigos e links recomendados</h2>
<p>Uma das melhores explicações que já encontrei sobre LSTM e GRU: <a class="reference external" href="https://towardsdatascience.com/illustrated-guide-to-lstms-and-gru-s-a-step-by-step-explanation-44e9eb85bf21">Illustrated Guide to LSTM’s and GRU’s: A step by step explanation</a></p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup>
<col class="label">
<col>
</colgroup>
<tbody valign="top"><tr>
<td class="label"><a class="fn-backref" href="posts/gru-e-lstm/#id1">[1]</a></td>
<td><a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.55.5709">Learning to Forget: Continual Prediction with LSTM ( Felix A. Gers , Jürgen Schmidhuber , Fred Cummins )</a></td>
</tr></tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup>
<col class="label">
<col>
</colgroup>
<tbody valign="top"><tr>
<td class="label"><a class="fn-backref" href="posts/gru-e-lstm/#id2">[2]</a></td>
<td><a class="reference external" href="https://www.researchgate.net/profile/Sepp_Hochreiter/publication/13853244_Long_Short-term_Memory/links/5700e75608aea6b7746a0624/Long-Short-term-Memory.pdf?origin=publication_detail">Long short-term memory (Sepp Hochreiter; Jürgen Schmidhuber)</a></td>
</tr></tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup>
<col class="label">
<col>
</colgroup>
<tbody valign="top"><tr>
<td class="label"><a class="fn-backref" href="posts/gru-e-lstm/#id3">[3]</a></td>
<td><a class="reference external" href="https://arxiv.org/pdf/1406.1078v3.pdf">Learning Phrase Representations using RNN Encoder–Decoder for Statistical Machine Translation ( Cho, Kyunghyun; van Merrienboer, Bart; Gulcehre, Caglar; Bahdanau, Dzmitry; Bougares, Fethi; Schwenk, Holger; Bengio, Yoshua)</a></td>
</tr></tbody>
</table>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/seq2seq-implementacao/" class="u-url">Seq2Seq - Implementação</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Lincoln de Macêdo
            </span></p>
            <p class="dateline">
            <a href="posts/seq2seq-implementacao/" rel="bookmark">
            <time class="published dt-published" datetime="2018-12-24T02:13:25-03:00" itemprop="datePublished" title="2018-12-24 02:13">2018-12-24 02:13</time></a>
            </p>
                <p class="commentline">
        
    <a href="posts/seq2seq-implementacao/#disqus_thread" data-disqus-identifier="cache/posts/seq2seq-implementacao.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <span></span>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/seq2seq-introducao/" class="u-url">Seq2Seq - Introdução</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Lincoln de Macêdo
            </span></p>
            <p class="dateline">
            <a href="posts/seq2seq-introducao/" rel="bookmark">
            <time class="published dt-published" datetime="2018-12-24T02:13:03-03:00" itemprop="datePublished" title="2018-12-24 02:13">2018-12-24 02:13</time></a>
            </p>
                <p class="commentline">
        
    <a href="posts/seq2seq-introducao/#disqus_thread" data-disqus-identifier="cache/posts/seq2seq-introducao.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>Tenho certeza que todos ao menos uma vez se perguntaram, pelo menos nas primeiras vezes que usaram o google translate, "como é que isso funciona? é magica?", até mesmo pelo que escrevi aqui até agora, todos os conteúdos estão bastante distantes de algo que trate tão intensamente com linguagem do que o desta anotação. O seq2seq nos permite criar redes que aprendam a sequência em que as palavras estão dispostas num texto de modo que fique fácil gerar textos, por hora, para simplificar esse assunto bastante extendo, traterei aqui apenas de explicar cada passo praticamente sem o código e na próxima anotação terá uma implementação completa.</p>
<div class="section" id="encoder-decoder">
<h2>encoder - decoder</h2>
<p>O grande "truque" está no mecanismo de codificação-decodificação, na prática são 2 redes neurais recorrentes bem simples que compartilham uma mesma camada oculta e não tem camada de ativação, só uma célula <cite>GRU ou LSTM &lt;link://filename/posts/gru-e-lstm.rst&gt;_</cite> que realiza o processamento.</p>
<p>A informação que dá sentido à ambas as redes é a camada oculta, é sobre ela que incide o treinamento, portanto essa é a camada responsável por fazer a relação entre as saídas de cada rede neural.</p>
<p>Mas por não haver uma classificação, precisaremos de mais uma rede neural (3 até agora) que será como a rede de decodificação mas com funções de ativação para que sobre ela seja realizado o treinamento da camada oculta.</p>
<p>Então o que temos até o momento é:</p>
<ul>
<li>
<p class="first">encoder:</p>
<blockquote>
<ul class="simple">
<li>hidden layer</li>
<li>gru</li>
</ul>
</blockquote>
</li>
<li>
<p class="first">decoder:</p>
<blockquote>
<ul class="simple">
<li>hidden layer</li>
<li>gru</li>
</ul>
</blockquote>
</li>
<li>
<p class="first">att decoder:</p>
<blockquote>
<ul class="simple">
<li>hidden layer</li>
<li>gru</li>
<li>função linear</li>
</ul>
</blockquote>
</li>
</ul>
</div>
<div class="section" id="treinamento">
<h2>Treinamento</h2>
<p>Como já disse que tudo está em torno da camada oculta compartilhada, é criando este array que se inicia o treinamento, que incide mais sobre a camada de decodificação que sobre a de encodificação, é feito desse modo pela camada de decodificação ser a usada para calcular a perda já que é ela que nos fornecerá a saída final do algoritmo.</p>
<p>Procedimento:</p>
<ul class="simple">
<li>hidden layer</li>
<li>encoder_output, hidden_layer = encoder(input, hidden_layer)</li>
<li>decoder_output, hidden_layer = decoder(encoder_output, hidden_layer)</li>
<li>loss(decoder_output, target)</li>
<li>backward</li>
<li>step</li>
</ul>
<p>Na próxima anotação sobre o seq2seq, diante do código, tudo ficará mais claro.</p>
<p>Resolvi não colocar imagens ilustrativas aqui pois no 1º link das leituras recomendadas há um monte de animações explicando bem detalhadamente todo o processo, das 2 leituras recomendadas, essa é a que mais recomendo.</p>
<p>---</p>
</div>
<div class="section" id="leituras-recomendadas">
<h2>leituras recomendadas</h2>
<ul class="simple">
<li><a class="reference external" href="http://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/">http://jalammar.github.io/visualizing-neural-machine-translation-mechanics-of-seq2seq-models-with-attention/</a></li>
<li><a class="reference external" href="https://google.github.io/seq2seq/">https://google.github.io/seq2seq/</a></li>
</ul>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/classificacao-1/" class="u-url">Classificação 1</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Lincoln de Macêdo
            </span></p>
            <p class="dateline">
            <a href="posts/classificacao-1/" rel="bookmark">
            <time class="published dt-published" datetime="2018-12-24T02:12:26-03:00" itemprop="datePublished" title="2018-12-24 02:12">2018-12-24 02:12</time></a>
            </p>
                <p class="commentline">
        
    <a href="posts/classificacao-1/#disqus_thread" data-disqus-identifier="cache/posts/classificacao-1.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>O problema fundamental da classificação de textos reside no fato da dificuldade de representar o texto a nível numérico, ainda que o word2vec, o glove, o seq2seq sejam realmente úteis assim como vários outros algoritmos que não incluí aqui mas que são facilmente encontrados em buscas no google, eles por si só não conseguem ir além da representação semântica ou de alguma outra lógica sobre as palavras, tanto para gerar textos quanto para classificá-los precisamos do auxílio de outros algoritmos. O objetivo desta anotação é identificar os desafions inerentes a esta tarefa.</p>
<div class="section" id="apenas-vocabulario">
<h2>Apenas vocabulário</h2>
<p>Esse seria o caminho mais óbvio, tendo em vista que temos uma representação espacial da disposição das palavras num hiperplano, então faz sentido imaginar que textos sobre diferentes assuntos necessariamente tem diferentes vocabulários. Façamos um teste:</p>
<ol class="arabic">
<li>
<p class="first">peguei 2 textos da wikipedia:</p>
<blockquote>
<ol class="loweralpha simple">
<li>
<a class="reference external" href="https://pt.wikipedia.org/wiki/Lutefisk">Lutefisk</a> - um prato da culinária norueguesa</li>
<li>
<a class="reference external" href="https://pt.wikipedia.org/wiki/Erhu">Erhu</a> - um instrumento tradicional chinês</li>
</ol>
</blockquote>
</li>
<li>
<p class="first">fiz o pré-processamento das palavras como já descrito em outro post, ficando apenas com o vocabulário</p>
</li>
<li>
<p class="first">peguei as posições correspondentes a cada palavra no skip-gram já treinado</p>
</li>
<li>
<p class="first">reduzi as dimensões e plotei o gráfico</p>
</li>
</ol>
<img alt="/images/classificacao_1_scatter_voc.png" src="images/classificacao_1_scatter_voc.png"><p><a href="posts/classificacao-1/#id1"><span class="problematic" id="id2">**</span></a>explicando as cores:</p>
<div class="system-message" id="id1">
<p class="system-message-title">System Message: WARNING/2 (<tt class="docutils">&lt;string&gt;</tt>, line 19); <em><a href="posts/classificacao-1/#id2">backlink</a></em></p>
Inline strong start-string without end-string.</div>
<!-- vermelho: vocabulário do texto 1 -->
<!-- ciano: vocabulário do texto 2 -->
<!-- branco: vocabulário em comum a ambos -->
<p>Como é possível perceber acima, não identificamos um nível de separação consistente entre os vocabulários, olhando a densidade de concentração do vocabulário nos dois textos, descartando as palavras em comum, temos a imagem abaixo:</p>
<img alt="/images/classificação_1_kde_voc.png" src="images/classifica%C3%A7%C3%A3o_1_kde_voc.png"><p>Os centros estão muito próximos, ou seja, mesmo identificando as regiões mais densas nos vocabulários, ao tentar usar esta região como métrica, a similaridade de sentido entre os termos para o texto 1 e para o texto 2 continuam muito próximas tornando essa estratégia bem ineficaz.</p>
<p>A solução está na compreensão que um texto não são apenas palavras soltas, mas o sentifo extrapola a simples junção de palavras, então a ordem do que está escrito importa, a disposição das palavras no texto importa muito.</p>
<p>Nas próximas anotações abordarei sobre o uso de redes convolucionais e redes neurais recorrentes, diferentes formas de tentar burlar as dificuldades aqui apresentadas.</p>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/" class="u-url">Distância Euclidiama vs Similaridade de Cossenos</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Lincoln de Macêdo
            </span></p>
            <p class="dateline">
            <a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/" rel="bookmark">
            <time class="published dt-published" datetime="2018-12-07T04:04:17-03:00" itemprop="datePublished" title="2018-12-07 04:04">2018-12-07 04:04</time></a>
            </p>
                <p class="commentline">
        
    <a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#disqus_thread" data-disqus-identifier="cache/posts/distancia-euclidiama-vs-similaridade-de-cossenos.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>Indo direto ao ponto a principal diferença entre os cálculos é que enquanto na distância euclidiana é como se fizéssemos uma medição com uma régua entre 2 pontos, na similaridade de cossenos analisamos a distância angular entre 2 pontos a partir da origem, isso ficará mais claro no gráfico perto do final desta anotação.</p>
<div class="math">
\begin{equation*}
dist\_eucl = \sqrt{\sum{(a-b)^2}}
\end{equation*}
</div>
<div class="math">
\begin{equation*}
cosine\_sim = \frac{\sqrt{\sum{a * b}}}{\sqrt{\sum{a^2}} * \sqrt{\sum{b^2}}}
\end{equation*}
</div>
<div class="section" id="comparando-resultados">
<h2>Comparando resultados</h2>
<p>Primeiro vamos implementar cada cálculo e depois uma função que receba uma matriz, normalize os dados, e indike os "k" pontos mais próximos a alguma coordenada que a gente escolher. Como usaremos em outras anotações, escrevi mais linhas do que um código simples e didático deveria ter:</p>
<table class="codetable"><tr>
<td class="linenos"><div class="linenodiv"><pre><a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-1"> 1</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-2"> 2</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-3"> 3</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-4"> 4</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-5"> 5</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-6"> 6</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-7"> 7</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-8"> 8</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-9"> 9</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-10">10</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-11">11</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-12">12</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-13">13</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-14">14</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-15">15</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-16">16</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-17">17</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-18">18</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-19">19</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-20">20</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-21">21</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-22">22</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-23">23</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-24">24</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-25">25</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-26">26</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-27">27</a>
<a href="posts/distancia-euclidiama-vs-similaridade-de-cossenos/#rest_code_7361953c4e44408fbac34e1192d4a6f5-28">28</a></pre></div></td>
<td class="code"><pre class="code python"><a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-1"></a><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-2"></a><span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">euclidean</span><span class="p">,</span> <span class="n">cosine</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-3"></a>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-4"></a><span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-5"></a>    <span class="k">return</span> <span class="n">x</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-6"></a>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-7"></a><span class="k">def</span> <span class="nf">knn</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="s2">"cos"</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-8"></a>    <span class="n">data_norm</span><span class="p">,</span> <span class="n">coord_norm</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-9"></a>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-10"></a>    <span class="k">if</span> <span class="s2">"coord"</span> <span class="ow">in</span> <span class="n">kw</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-11"></a>        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kw</span><span class="p">[</span><span class="s2">"coord"</span><span class="p">]])))</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-12"></a>        <span class="n">ata_norm</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-13"></a>        <span class="n">coord_norm</span> <span class="o">=</span> <span class="n">data_norm</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-14"></a>    <span class="k">else</span><span class="p">:</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-15"></a>        <span class="n">data_norm</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-16"></a>        <span class="n">coord_norm</span> <span class="o">=</span> <span class="n">data_norm</span><span class="p">[</span><span class="n">kw</span><span class="p">[</span><span class="s2">"pos"</span><span class="p">]]</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-17"></a>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-18"></a>    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-19"></a>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">data_norm</span><span class="p">:</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-20"></a>        <span class="k">if</span> <span class="n">func</span><span class="o">==</span><span class="s2">"cos"</span><span class="p">:</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-21"></a>            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cosine</span><span class="p">(</span><span class="n">coord_norm</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-22"></a>        <span class="k">else</span><span class="p">:</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-23"></a>            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">euclidean</span><span class="p">(</span><span class="n">coord_norm</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-24"></a>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-25"></a>    <span class="k">if</span> <span class="n">func</span><span class="o">==</span><span class="s2">"cos"</span><span class="p">:</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-26"></a>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">res</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-27"></a>    <span class="k">else</span><span class="p">:</span>
<a name="rest_code_7361953c4e44408fbac34e1192d4a6f5-28"></a>        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">()[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">res</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</pre></td>
</tr></table>
<p>Visualizando a diferença de resultados entre as medições, gerei esse gráfico abaixo:</p>
<a class="reference external image-reference" href="images/eucl_vs_cos.png"><img alt="/images/eucl_vs_cos.thumbnail.png" src="images/eucl_vs_cos.thumbnail.png" style="width: 500px;"></a>
<p>explicando: os pontos vermelhos representam os pontos mais próximos desse ponto amarelo cortado por uma seta são os pontos mais próximos considerando a distância euclidiana, os pontos azuis é pela similaridade de cossenos e os roxos são os que as duas métricas coincidem ao listar os mais próximos, a seta indica a inclinação do ponto amarelo em relação a origem, e é isso que a similaridade de cossenos leva em consideração, perceba que um dos pontos azuis ficou bem distante mas projetando a seta vemos que se mantém mais próximo ao ângulo do ponto amarelo que o ponto vemelho.</p>
<p>O motivo de preferirmos usar a similaridade de cossenos a usar distância euclidiana ou outras métricas para medir distâncias é que quando trabalhamos com NLP e ainda mais quando fazemos uma redução de dimensionalidade (onde ficou claro que há rotação e distorção) os ângulos ficam mais bem preservados que as distâncias.</p>
<p>obs: É muito comum a similaridade é calculada com 1 passo a mais do que o demonstrado aqui, a distância angular é dada por:</p>
<div class="math">
\begin{equation*}
dist\_angular = \frac{cos^-1(cos\_similarity)}{\pi}
\end{equation*}
</div>
<div class="math">
\begin{equation*}
angular\_similarity = 1-dist\_angular
\end{equation*}
</div>
<p>Outras vezes apenas fazem <strong>1-similaridade</strong>.</p>
<div class="notebook">
    <a class="notebook-link" href="http://nbviewer.jupyter.org/github/demacdolincoln/anotacoes-nlp/blob/src/files/knn_eucl_cos.ipynb">code</a>
</div>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/estatistica-tf-idf-e-lsa/" class="u-url">Estatística: TF-IDF e LSA</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Lincoln de Macêdo
            </span></p>
            <p class="dateline">
            <a href="posts/estatistica-tf-idf-e-lsa/" rel="bookmark">
            <time class="published dt-published" datetime="2018-12-07T01:47:59-03:00" itemprop="datePublished" title="2018-12-07 01:47">2018-12-07 01:47</time></a>
            </p>
                <p class="commentline">
        
    <a href="posts/estatistica-tf-idf-e-lsa/#disqus_thread" data-disqus-identifier="cache/posts/estatistica-tf-idf-e-lsa.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>Antes da popularidade de métodos baseados em IA, muito também devido à capacidade dos computadores da época, o que restava para análises de texto era quantificar as palavras e buscar extrair estatísticas, o mais básico e fundamental talvez seja o TF-IDF e por isso este post.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name">
<col class="field-body">
<tbody valign="top"><tr class="field">
<th class="field-name">tf-idf:</th>
<td class="field-body"><em>frequency-inverse document frequency</em></td>
</tr></tbody>
</table>
<p>Este método se resume a contar a frequência de uso de palavras e realizar um cálculo que gere uma estimativa de uso/importância da palavra no texto, de certa forma ele se conecta à <a class="reference external" href="https://en.wikipedia.org/wiki/Zipf%27s_law">Lei de Zipf</a> que trata justamente de uma análise da frequência de palavras.</p>
<div class="math">
\begin{equation*}
TF(t) = \frac{nº\ de\ vezes\ que\ t\ aparece\ no\ texto}{total\ de\ termos\ no\ texto}
\end{equation*}
</div>
<div class="math">
\begin{equation*}
IDF(t) = log_e(\frac{quantidade\ total\ de\ textos}{numero\ de\ textos\ em\ que\ t\ aparece})
\end{equation*}
</div>
<p>Recomendo bastante a wikipédia em inglês, há bastante exemplos de cálculos variantes: <a class="reference external" href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">https://en.wikipedia.org/wiki/Tf%E2%80%93idf</a></p>
<p>Logicamente há inconsistências, afinal apenas a frequência não alcança o uso das palavras, não indica necessariamente as mais significativas se uma pessoa em vez de fazer referências a uma palavra ficar repetindo a mesma coisa o tempo todo. ex.:</p>
<!--  -->
<blockquote>
<p>"há filmes bons, ruins e medianos, mas o filme em questão é o pior de todos, o filme é tão chato e cansativo que todos dormem assistindo os primeiros minutos do filme"</p>
<p>"há filmes bons, ruins e medianos, mas este em questão é o pior de todos, tão chato e cansativo que todos dormem aos primeiros minutos"</p>
</blockquote>
<p>É bem claro que apesar do sentido do texto ser o mesmo, a importância dada à palavra "filme" seria diferente. E de fato, o TF-IDF funciona melhor para textos que seguem as regras de coesão e coerência, então vamos usar publicações da wikipédia.</p>
<p>Apesar do cálculo ser bastante simples, vou preferir usar o sklearn pois neste caso o mais importante é ter uma ideia geral sobre um recurso básico e servir como uma introdução básica sobre NLP, especialmente sobre vertorização de textos</p>
<div class="section" id="tf-idf">
<h2>TF-IDF</h2>
<p>Como quase tudo no sklearn...</p>
<table class="codetable"><tr>
<td class="linenos"><div class="linenodiv"><pre><a href="posts/estatistica-tf-idf-e-lsa/#rest_code_34e6594eb158474ab1576df2ac03ec24-1"> 1</a>
<a href="posts/estatistica-tf-idf-e-lsa/#rest_code_34e6594eb158474ab1576df2ac03ec24-2"> 2</a>
<a href="posts/estatistica-tf-idf-e-lsa/#rest_code_34e6594eb158474ab1576df2ac03ec24-3"> 3</a>
<a href="posts/estatistica-tf-idf-e-lsa/#rest_code_34e6594eb158474ab1576df2ac03ec24-4"> 4</a>
<a href="posts/estatistica-tf-idf-e-lsa/#rest_code_34e6594eb158474ab1576df2ac03ec24-5"> 5</a>
<a href="posts/estatistica-tf-idf-e-lsa/#rest_code_34e6594eb158474ab1576df2ac03ec24-6"> 6</a>
<a href="posts/estatistica-tf-idf-e-lsa/#rest_code_34e6594eb158474ab1576df2ac03ec24-7"> 7</a>
<a href="posts/estatistica-tf-idf-e-lsa/#rest_code_34e6594eb158474ab1576df2ac03ec24-8"> 8</a>
<a href="posts/estatistica-tf-idf-e-lsa/#rest_code_34e6594eb158474ab1576df2ac03ec24-9"> 9</a>
<a href="posts/estatistica-tf-idf-e-lsa/#rest_code_34e6594eb158474ab1576df2ac03ec24-10">10</a>
<a href="posts/estatistica-tf-idf-e-lsa/#rest_code_34e6594eb158474ab1576df2ac03ec24-11">11</a>
<a href="posts/estatistica-tf-idf-e-lsa/#rest_code_34e6594eb158474ab1576df2ac03ec24-12">12</a>
<a href="posts/estatistica-tf-idf-e-lsa/#rest_code_34e6594eb158474ab1576df2ac03ec24-13">13</a>
<a href="posts/estatistica-tf-idf-e-lsa/#rest_code_34e6594eb158474ab1576df2ac03ec24-14">14</a></pre></div></td>
<td class="code"><pre class="code python"><a name="rest_code_34e6594eb158474ab1576df2ac03ec24-1"></a><span class="kn">import</span> <span class="nn">wikipedia</span>
<a name="rest_code_34e6594eb158474ab1576df2ac03ec24-2"></a><span class="kn">from</span> <span class="nn">nltk.corpus</span> <span class="kn">import</span> <span class="n">stopwords</span>
<a name="rest_code_34e6594eb158474ab1576df2ac03ec24-3"></a><span class="kn">from</span> <span class="nn">sklearn.feature_extraction.text</span> <span class="kn">import</span> <span class="n">TfidfVectorizer</span>
<a name="rest_code_34e6594eb158474ab1576df2ac03ec24-4"></a>
<a name="rest_code_34e6594eb158474ab1576df2ac03ec24-5"></a><span class="n">stopw</span> <span class="o">=</span> <span class="n">stopwords</span><span class="o">.</span><span class="n">words</span><span class="p">(</span><span class="s2">"portuguese"</span><span class="p">)</span> <span class="o">+</span>\
<a name="rest_code_34e6594eb158474ab1576df2ac03ec24-6"></a>        <span class="n">stopwords</span><span class="o">.</span><span class="n">words</span><span class="p">(</span><span class="s2">"english"</span><span class="p">)</span>
<a name="rest_code_34e6594eb158474ab1576df2ac03ec24-7"></a>
<a name="rest_code_34e6594eb158474ab1576df2ac03ec24-8"></a><span class="n">wikipedia</span><span class="o">.</span><span class="n">set_lang</span><span class="p">(</span><span class="s2">"pt"</span><span class="p">)</span>
<a name="rest_code_34e6594eb158474ab1576df2ac03ec24-9"></a><span class="n">text</span> <span class="o">=</span> <span class="n">wikipedia</span><span class="o">.</span><span class="n">page</span><span class="p">(</span><span class="s2">"Alan_Turing"</span><span class="p">)</span><span class="o">.</span><span class="n">content</span>
<a name="rest_code_34e6594eb158474ab1576df2ac03ec24-10"></a>
<a name="rest_code_34e6594eb158474ab1576df2ac03ec24-11"></a><span class="n">tfidf</span> <span class="o">=</span> <span class="n">TfidfVectorizer</span><span class="p">(</span><span class="n">stop_words</span><span class="o">=</span><span class="n">stopw</span><span class="p">)</span>
<a name="rest_code_34e6594eb158474ab1576df2ac03ec24-12"></a>
<a name="rest_code_34e6594eb158474ab1576df2ac03ec24-13"></a><span class="n">X</span> <span class="o">=</span> <span class="n">tfidf</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">splitlines</span><span class="p">())</span>
<a name="rest_code_34e6594eb158474ab1576df2ac03ec24-14"></a><span class="n">X</span><span class="o">.</span><span class="n">shape</span>
</pre></td>
</tr></table>
<p>Na penúltima linha usei o <cite>splitlines</cite> para dividir o texto em parágrafos, assim podemos posteriormente coletar informações sobre os termos relevantes para cada parágrafo, mas admito esta forma ser demasiadamente simplista pois neste caso acabo considerando subtítulos como parágrafos.</p>
<p>Internamente, o objeto que criamos, durante o treinamento, armazena um dicionário com as palavras e um "id", vamos usar isso para converter os termos:</p>
<pre class="code python"><a name="rest_code_13bdd8d59ba844dcbc93ff2b1ac1af6c-1"></a><span class="o">&gt;&gt;&gt;</span> <span class="n">X</span>
<a name="rest_code_13bdd8d59ba844dcbc93ff2b1ac1af6c-2"></a><span class="o">&lt;</span><span class="mi">61</span><span class="n">x664</span> <span class="n">sparse</span> <span class="n">matrix</span> <span class="n">of</span> <span class="nb">type</span> <span class="s1">'&lt;class '</span><span class="n">numpy</span><span class="o">.</span><span class="n">float64</span><span class="s1">'&gt;'</span>
<a name="rest_code_13bdd8d59ba844dcbc93ff2b1ac1af6c-3"></a>    <span class="k">with</span> <span class="mi">862</span> <span class="n">stored</span> <span class="n">elements</span> <span class="ow">in</span> <span class="n">Compressed</span> <span class="n">Sparse</span> <span class="n">Row</span> <span class="n">format</span><span class="o">&gt;</span>
</pre>
<p>A matriz esparsa tem diversas vantagens quando tratamos com longos arrays rechados de zeros, talvez o produto principal nessa implementação seja exatamente essa matriz que indica em cada parágrafo quais os termos presentes e a sua frequência, que é o ponto principal do TF-IDF.</p>
<img alt="visualização da matriz resultante" src="images/lsa.png"><p>E é exatamente sobre essa matriz que chegamos no LSA (Latent Semantic Analysis), mas antes vamos ver quais as palavras mais relevantes do primeiro parágrafo:</p>
<pre class="code python"><a name="rest_code_160098d8b64746b1997153fbce992da6-1"></a><span class="o">&gt;&gt;&gt;</span> <span class="n">ft_name</span> <span class="o">=</span> <span class="n">tfidf</span><span class="o">.</span><span class="n">get_feature_names</span><span class="p">()</span>
<a name="rest_code_160098d8b64746b1997153fbce992da6-2"></a><span class="o">&gt;&gt;&gt;</span> <span class="n">top_tfidf</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<a name="rest_code_160098d8b64746b1997153fbce992da6-3"></a><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">top_tfidf</span><span class="p">[:</span><span class="mi">10</span><span class="p">]:</span>
<a name="rest_code_160098d8b64746b1997153fbce992da6-4"></a>        <span class="k">print</span><span class="p">(</span><span class="n">ft_name</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<a name="rest_code_160098d8b64746b1997153fbce992da6-5"></a>
<a name="rest_code_160098d8b64746b1997153fbce992da6-6"></a><span class="n">computação</span>
<a name="rest_code_160098d8b64746b1997153fbce992da6-7"></a><span class="n">cheshire</span>
<a name="rest_code_160098d8b64746b1997153fbce992da6-8"></a><span class="n">junho</span>
<a name="rest_code_160098d8b64746b1997153fbce992da6-9"></a><span class="n">ciência</span>
<a name="rest_code_160098d8b64746b1997153fbce992da6-10"></a><span class="n">influente</span>
<a name="rest_code_160098d8b64746b1997153fbce992da6-11"></a><span class="n">algoritmo</span>
<a name="rest_code_160098d8b64746b1997153fbce992da6-12"></a><span class="n">east</span>
<a name="rest_code_160098d8b64746b1997153fbce992da6-13"></a><span class="n">lógico</span>
<a name="rest_code_160098d8b64746b1997153fbce992da6-14"></a><span class="n">desenvolvimento</span>
<a name="rest_code_160098d8b64746b1997153fbce992da6-15"></a><span class="n">desempenhando</span>
</pre>
<p>O ft_name é a lista de termos que irá converter para string a posição do termo indicada quando ordenamos o array comtendo o valor calculado para cada termo devolvendo as respectivas posições.</p>
</div>
<div class="section" id="lsa">
<h2>LSA</h2>
<p>O LSA é nada mais que usar o <a class="reference external" href="posts/svd-vs-pca">SVD</a> mas em vez de diminuir as dimensões vamos manter o tamanho da matriz:</p>
<pre class="code python"><a name="rest_code_e85c4ba69569446fa6efd42b17e1cce0-1"></a><span class="o">&gt;&gt;&gt;</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
<a name="rest_code_e85c4ba69569446fa6efd42b17e1cce0-2"></a><span class="p">(</span><span class="mi">61</span><span class="p">,</span> <span class="mi">664</span><span class="p">)</span>
<a name="rest_code_e85c4ba69569446fa6efd42b17e1cce0-3"></a>
<a name="rest_code_e85c4ba69569446fa6efd42b17e1cce0-4"></a><span class="o">&gt;&gt;&gt;</span> <span class="n">lsa</span> <span class="o">=</span> <span class="n">TruncatedSVD</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">61</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<a name="rest_code_e85c4ba69569446fa6efd42b17e1cce0-5"></a><span class="o">&gt;&gt;&gt;</span> <span class="n">lsa</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
<a name="rest_code_e85c4ba69569446fa6efd42b17e1cce0-6"></a><span class="n">TruncatedSVD</span><span class="p">(</span><span class="n">algorithm</span><span class="o">=</span><span class="s1">'randomized'</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span><span class="mi">61</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
<a name="rest_code_e85c4ba69569446fa6efd42b17e1cce0-7"></a>   <span class="n">random_state</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
</pre>
<p>O real poder do LSA vem desse tratamento dado à matriz formada a partir do TF-IDF, o código abaixo indica as palavras mais relevantes para cada parágrafo:</p>
<pre class="code python"><a name="rest_code_cf73a290231c404e81b2744e9deead7d-1"></a><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lsa</span><span class="o">.</span><span class="n">components_</span><span class="p">):</span>
<a name="rest_code_cf73a290231c404e81b2744e9deead7d-2"></a>    <span class="n">terms_in_comp</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ft_name</span><span class="p">,</span> <span class="n">comp</span><span class="p">)</span>
<a name="rest_code_cf73a290231c404e81b2744e9deead7d-3"></a>    <span class="n">sorted_terms</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">terms_in_comp</span><span class="p">,</span>
<a name="rest_code_cf73a290231c404e81b2744e9deead7d-4"></a>                          <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)[:</span><span class="mi">10</span><span class="p">]</span>
<a name="rest_code_cf73a290231c404e81b2744e9deead7d-5"></a>
<a name="rest_code_cf73a290231c404e81b2744e9deead7d-6"></a>    <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s2">"paragrafo: {i}"</span><span class="p">)</span>
<a name="rest_code_cf73a290231c404e81b2744e9deead7d-7"></a>    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">sorted_terms</span><span class="p">:</span>
<a name="rest_code_cf73a290231c404e81b2744e9deead7d-8"></a>        <span class="k">print</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<a name="rest_code_cf73a290231c404e81b2744e9deead7d-9"></a>    <span class="k">print</span><span class="p">(</span><span class="s2">"-"</span><span class="o">*</span><span class="mi">20</span><span class="p">)</span>
</pre>
<p>Pegando apenas o parágrafo 0, o resultado que temos é:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name">
<col class="field-body">
<tbody valign="top"><tr class="field">
<th class="field-name">paragrafo 0:</th>
<td class="field-body"><ul class="first last simple">
<li>turing</li>
<li>máquina</li>
<li>alan</li>
<li>prêmio</li>
<li>memorial</li>
<li>guerra</li>
<li>enigma</li>
<li>bletchley</li>
<li>park</li>
<li>computação</li>
</ul></td>
</tr></tbody>
</table>
</div>
<div class="section" id="off-topic">
<h2>off-topic</h2>
<ol class="arabic simple">
<li>E para gerar estatísticas de relevância de um texto inteiro, basta não dividir em parágrafos</li>
<li>E para gerarmos aquele bag of words que está na moda temos algumas opções, dependendo do caso aplicamos só o <strong>TF</strong> para gerar um ranking, para outros casos o <strong>TF-IDF</strong> funciona melhor, especialmente quando juntamos vários textos como uma análise geral de várias páginas de blogs, o LSA tende a ser melhor em usos mais específicos porém nada impede de usa-lo para gerar o ranking de termos para um livro, por exemplo.</li>
</ol>
<div class="notebook">
    <a class="notebook-link" href="http://nbviewer.jupyter.org/github/demacdolincoln/anotacoes-nlp/blob/src/files/estatistica-tf-idf-e-lsa.ipynb">code</a>
</div>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/word2vec-3-skip-gram/" class="u-url">word2vec 3: skip-gram</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Lincoln de Macêdo
            </span></p>
            <p class="dateline">
            <a href="posts/word2vec-3-skip-gram/" rel="bookmark">
            <time class="published dt-published" datetime="2018-12-07T01:43:36-03:00" itemprop="datePublished" title="2018-12-07 01:43">2018-12-07 01:43</time></a>
            </p>
                <p class="commentline">
        
    <a href="posts/word2vec-3-skip-gram/#disqus_thread" data-disqus-identifier="cache/posts/word2vec-3-skip-gram.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>Como já dito antes, o skip-gram faz um treinamento meio que ao contrário do cbow, no treinamento a rede neural recebe as palavras centrais para tentar prever as palavras de contexto e assim ajusta os pesos das camadas da rede neural aproximando valores para palavras semelhantes no hiperplano.</p>
<pre class="code python"><a name="rest_code_d7a929b15f6a469cada19f39350511fd-1"></a><span class="n">window</span> <span class="o">=</span> <span class="mi">2</span>
<a name="rest_code_d7a929b15f6a469cada19f39350511fd-2"></a><span class="n">pair_ids</span> <span class="o">=</span> <span class="p">[]</span>
<a name="rest_code_d7a929b15f6a469cada19f39350511fd-3"></a>
<a name="rest_code_d7a929b15f6a469cada19f39350511fd-4"></a><span class="n">text_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">corpus_text</span><span class="p">)</span>
<a name="rest_code_d7a929b15f6a469cada19f39350511fd-5"></a>
<a name="rest_code_d7a929b15f6a469cada19f39350511fd-6"></a><span class="n">corpus_text</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">corpus_text</span><span class="p">)</span>
<a name="rest_code_d7a929b15f6a469cada19f39350511fd-7"></a><span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
<a name="rest_code_d7a929b15f6a469cada19f39350511fd-8"></a>           <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">window</span><span class="p">,</span> <span class="n">window</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="mi">0</span><span class="p">]</span>
<a name="rest_code_d7a929b15f6a469cada19f39350511fd-9"></a>       <span class="p">)</span>
<a name="rest_code_d7a929b15f6a469cada19f39350511fd-10"></a>
<a name="rest_code_d7a929b15f6a469cada19f39350511fd-11"></a><span class="k">for</span> <span class="n">center_word</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">text_size</span><span class="o">-</span><span class="n">window</span><span class="p">):</span>
<a name="rest_code_d7a929b15f6a469cada19f39350511fd-12"></a>    <span class="n">center_word_id</span> <span class="o">=</span> <span class="n">word2id</span><span class="p">[</span><span class="n">corpus_text</span><span class="p">[</span><span class="n">center_word</span><span class="p">]]</span>
<a name="rest_code_d7a929b15f6a469cada19f39350511fd-13"></a>    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">corpus_text</span><span class="p">[</span><span class="n">mask</span> <span class="o">+</span> <span class="n">center_word</span><span class="p">]:</span>
<a name="rest_code_d7a929b15f6a469cada19f39350511fd-14"></a>        <span class="n">context_word_id</span> <span class="o">=</span> <span class="n">word2id</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<a name="rest_code_d7a929b15f6a469cada19f39350511fd-15"></a>        <span class="n">pair_ids</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">center_word_id</span><span class="p">,</span> <span class="n">context_word_id</span><span class="p">])</span>
<a name="rest_code_d7a929b15f6a469cada19f39350511fd-16"></a><span class="n">pair_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pair_ids</span><span class="p">)</span>
</pre>
<p>A única diferença do código acima para criar os pares de ids está na ordem: primeiro a palavra central e depois a palavra de contexto:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%">
<col width="25%">
<col width="25%">
<col width="25%">
</colgroup>
<thead valign="bottom"><tr>
<th class="head">central</th>
<th class="head">contexto</th>
<th class="head">central</th>
<th class="head">contexto</th>
</tr></thead>
<tbody valign="top">
<tr>
<td>604</td>
<td>97</td>
<td>máquina</td>
<td>desempenhando</td>
</tr>
<tr>
<td>75</td>
<td>302</td>
<td>turing</td>
<td>computação</td>
</tr>
<tr>
<td>75</td>
<td>604</td>
<td>turing</td>
<td>máquina</td>
</tr>
<tr>
<td>75</td>
<td>97</td>
<td>turing</td>
<td>desempenhando</td>
</tr>
<tr>
<td>75</td>
<td>277</td>
<td>turing</td>
<td>papel</td>
</tr>
<tr>
<td>97</td>
<td>604</td>
<td>desempenhando</td>
<td>máquina</td>
</tr>
<tr>
<td>97</td>
<td>75</td>
<td>desempenhando</td>
<td>turing</td>
</tr>
<tr>
<td>97</td>
<td>277</td>
<td>desempenhando</td>
<td>papel</td>
</tr>
<tr>
<td>97</td>
<td>409</td>
<td>desempenhando</td>
<td>importante</td>
</tr>
<tr>
<td>277</td>
<td>75</td>
<td>papel</td>
<td>turing</td>
</tr>
<tr>
<td>277</td>
<td>97</td>
<td>papel</td>
<td>desempenhando</td>
</tr>
</tbody>
</table>
<p>O modelo da rede neural não se difere muito da usada no cbow, a única diferença fica por conta do tamanho da entrada da primeira função linear, já que passaremos 1 id por vez e não 4 como no cbow.</p>
<pre class="code python"><a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-1"></a><span class="k">class</span> <span class="nc">CBOW</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-2"></a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vocab_size</span><span class="p">,</span> <span class="n">emb_size</span><span class="p">):</span>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-3"></a>        <span class="nb">super</span><span class="p">(</span><span class="n">CBOW</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-4"></a>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-5"></a>        <span class="bp">self</span><span class="o">.</span><span class="n">embeddings</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Embedding</span><span class="p">(</span><span class="n">vocab_size</span><span class="p">,</span> <span class="n">emb_size</span><span class="p">)</span>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-6"></a>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-7"></a>        <span class="bp">self</span><span class="o">.</span><span class="n">linear0</span> <span class="o">=</span>  <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">emb_size</span><span class="p">,</span> <span class="mi">512</span><span class="p">)</span> <span class="c1"># única diferença aqui</span>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-8"></a>        <span class="bp">self</span><span class="o">.</span><span class="n">linear1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="n">vocab_size</span><span class="p">)</span>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-9"></a>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-10"></a>        <span class="bp">self</span><span class="o">.</span><span class="n">log_softmax</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">LogSoftmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-11"></a>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-12"></a>    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-13"></a>        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embeddings</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-14"></a>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-15"></a>        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear0</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-16"></a>        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linear1</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-17"></a>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-18"></a>        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_softmax</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-19"></a>        <span class="k">return</span> <span class="n">out</span>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-20"></a>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-21"></a>    <span class="k">def</span> <span class="nf">get_word_emb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word_id</span><span class="p">):</span>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-22"></a>        <span class="n">word</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">LongTensor</span><span class="p">([</span><span class="n">word_id</span><span class="p">])</span>
<a name="rest_code_bfb053bc8fe84bd6bc826f8dc55d430a-23"></a>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">embeddings</span><span class="p">(</span><span class="n">word</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre>
<p>De modo geral o nível de erro (ou perda, nunca sei ao certo como traduzir "loss" neste contexto) no skip-gram é maior que no cbow, mas repito que o importante é que esteja havendo um aprendizado e não que a rede neural se adapte ao ponto de prever todas as palavras relacionadas ainda que ocasionalmente isso ocorra, para nós interessa o seguinte movimento: numa época a rede neural elevar os valores das palavras próximas na saída e afastar as mais distantes, assim naturalmente ela vai aprendendo a agrupar palavras em regiões de um hiperplano aproximando ou afastando de acordo com o modo como as palavras são usadas, tendendo a manter um distanciamento relacionado ao seu valor semântico.</p>
<img alt="/images/word2vec-skipgram-loss.png" src="images/word2vec-skipgram-loss.png"><p>Reduzindo as dimensões para visualizar a distribuição...</p>
<img alt="/images/word2vec-skipgram-1.png" src="images/word2vec-skipgram-1.png" style="width: 500px;"><p>Logicamente dessa forma como implementei, o custo/perda/loss é mais alto que na implementação feita do cbow, afinal vamos aos poucos ajustando 4 resultados possíveis para cada termo. Neste exemplo aumentei a quantidade de épocas para 2500 e ainda assim ficou imensamente distante do resultado da implementação do cbow neste aspecto, porém a relação entre as palavras se mostrou um pouco melhor ainda que longe do ideal.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%">
<col width="25%">
<col width="25%">
<col width="25%">
</colgroup>
<thead valign="bottom"><tr>
<th class="head">rank sim cos</th>
<th class="head"><ul class="first last simple"><li>
</li></ul></th>
<th class="head">rank dist eucl</th>
<th class="head"><ul class="first last simple"><li>
</li></ul></th>
</tr></thead>
<tbody valign="top">
<tr>
<td>muitos</td>
<td>0.14544</td>
<td>muitos</td>
<td>0.07375</td>
</tr>
<tr>
<td>poderia</td>
<td>0.26087</td>
<td>code</td>
<td>0.08692</td>
</tr>
<tr>
<td>ceruzzi</td>
<td>0.28141</td>
<td>ceruzzi</td>
<td>0.08939</td>
</tr>
<tr>
<td>code</td>
<td>0.28206</td>
<td>condados</td>
<td>0.09595</td>
</tr>
<tr>
<td>britânica</td>
<td>0.28430</td>
<td>mortem</td>
<td>0.09709</td>
</tr>
<tr>
<td>mortem</td>
<td>0.33544</td>
<td>atos</td>
<td>0.10284</td>
</tr>
<tr>
<td>condenado</td>
<td>0.33660</td>
<td>teórica</td>
<td>0.10357</td>
</tr>
<tr>
<td>comerciantes</td>
<td>0.33929</td>
<td>condenado</td>
<td>0.10376</td>
</tr>
<tr>
<td>cabeceira</td>
<td>0.34548</td>
<td>rápido</td>
<td>0.10433</td>
</tr>
<tr>
<td>condados</td>
<td>0.36041</td>
<td>prazer</td>
<td>0.10648</td>
</tr>
</tbody>
</table>
<img alt="/images/word2vec-skipgram-rank.png" src="images/word2vec-skipgram-rank.png"><p>Só lembrando que segui o mesmo padrão de cores:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name">
<col class="field-body">
<tbody valign="top">
<tr class="field">
<th class="field-name">amarelo:</th>
<td class="field-body">Palavra escolhida</td>
</tr>
<tr class="field">
<th class="field-name">vermelho:</th>
<td class="field-body">Termos mais próximos pela similaridade de cossenos</td>
</tr>
<tr class="field">
<th class="field-name">azul:</th>
<td class="field-body">Termos mais próximos pela distância euclidiana</td>
</tr>
<tr class="field">
<th class="field-name">roxo:</th>
<td class="field-body">Termos que ambas as métricas concordam</td>
</tr>
</tbody>
</table>
<div class="notebook">
    <a class="notebook-link" href="http://nbviewer.jupyter.org/github/demacdolincoln/anotacoes-nlp/blob/src/files/word2vec-3-skipgram.ipynb">code</a>
</div>
</div>
    </div>
    </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/svd-vs-pca/" class="u-url">SVD vs PCA</a></h1>
        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                Lincoln de Macêdo
            </span></p>
            <p class="dateline">
            <a href="posts/svd-vs-pca/" rel="bookmark">
            <time class="published dt-published" datetime="2018-12-07T01:26:29-03:00" itemprop="datePublished" title="2018-12-07 01:26">2018-12-07 01:26</time></a>
            </p>
                <p class="commentline">
        
    <a href="posts/svd-vs-pca/#disqus_thread" data-disqus-identifier="cache/posts/svd-vs-pca.html">Comments</a>


        </p>
</div>
    </header><div class="e-content entry-content">
    <div>
<p>Não vou tratar aqui de como se implementa o PCA e o SVD, prefiro indicar esses tutoriais abaixo, eles foram muito bem escritos e são muito claros sobre como são os cálculos usados:</p>
<ul class="simple">
<li><a class="reference external" href="https://sebastianraschka.com/Articles/2014_pca_step_by_step.html">tutorial PCA</a></li>
<li><a class="reference external" href="https://machinelearningmastery.com/singular-value-decomposition-for-machine-learning/">tutorial SVD</a></li>
</ul>
<p>Embora esses métodos possam ser usados para compressão de dados, análises populacionais e uma infinidade de análises envolvendo dados organizados em matrizes, aqui prefiro comparar cada método e discutir o uso voltado à redução de dimensões a fim que possamos visualizar os dados dessas anotações,</p>
<p>mas antes de chegar nas discussões, vamos ver alguns gráficos mostrando o que o SVD e o PCA retornaram quando os usamos para reduzir dimensões de matrizes:</p>
<img alt="/images/svd_pca_0_3d.png" src="images/svd_pca_0_3d.png"><img alt="/images/svd_pca_1_3dreduction.png" src="images/svd_pca_1_3dreduction.png"><p>curiosamente vemos que ocorreu uma rotação no gráfico do PCA e que o gráfico do SVD mantém uma certa similaridade visual com o gráfico original em 3D. Só compreendi melhor vendo <a class="reference external" href="https://www.quora.com/What-is-the-difference-between-PCA-and-SVD/answer/Adarsh-131">esta resposta no Quora</a>:</p>
<blockquote>
<p>"Geometrically PCA corresponds to “centering the dataset”, and then rotating it to align the axis of highest variance with the principle axis."</p>
<p><em>Geometricamente, PCA corresponde a "centralização do dataset", e depois rotaciona para alinhar o eixo de maior variância com o eixo principal</em></p>
</blockquote>
<p>Lógico que nem sempre acontece de ambos as representações ficarem tão diferentes, para observar melhor isso resolvi seguir um <a class="reference external" href="https://scikit-learn.org/stable/auto_examples/cluster/plot_kmeans_digits.html#sphx-glr-auto-examples-cluster-plot-kmeans-digits-py">exemplo da documentação do sklearn</a></p>
<img alt="/images/svd_pca_2_64reduction.png" src="images/svd_pca_2_64reduction.png"><p>A imagem acima mostra que deve ter coincidido a forma como o SVD reduziu as dimensões e a rotação feita pelo PCA, só lembrando o que está de forma muito explícita no link para o Quora: o PCA usa o SVD para criar um ranking, afinal PCA significa "análise do componente principal" e o SVD fornece um dos passos para chegar ao componente pricipal.</p>
<p>Mas o KMeans realiza um aprendizado não supervisionado, e ainda especialmente neste caso onde a redução de 64 dimensões para 2 com certeza não deu margem para que os dados fossem linearmente separáveis, resolvi usar o SVM para desenhar o espaço para cada classe.</p>
<img alt="/images/svd_pca_3_svm.png" src="images/svd_pca_3_svm.png"><p>Algo que se deve ressaltar no gráfico acima é que os pontos semi-transparentes que adicionei ao gráfico são os que os classificadores treinados erraram, sobre isso repare no resultado abaixo:</p>
<pre class="code text"><a name="rest_code_27e20de9dad84d098793720e7653c63b-1"></a>erros SVD: 704 de 1797
<a name="rest_code_27e20de9dad84d098793720e7653c63b-2"></a>erros PCA: 704 de 1797
<a name="rest_code_27e20de9dad84d098793720e7653c63b-3"></a>erros normal: 0 de 1797
<a name="rest_code_27e20de9dad84d098793720e7653c63b-4"></a>-----------------------
<a name="rest_code_27e20de9dad84d098793720e7653c63b-5"></a>percentuais de acertos:
<a name="rest_code_27e20de9dad84d098793720e7653c63b-6"></a>&gt; SVD: 60.824%
<a name="rest_code_27e20de9dad84d098793720e7653c63b-7"></a>&gt; pca: 60.824%
<a name="rest_code_27e20de9dad84d098793720e7653c63b-8"></a>&gt; normal: 100.000%
</pre>
<p>Considerei "normal" como a aplicação do SVM sem reduzir as dimensões. Estes resultados mostram que a sobreposição de dados na redução de dimensões assim como a distorção que ocorre nas transformações feitas com as matrizes, tende a dificultar o trabalho dos algoritmos, mesmo mantendo um certo nível de fidelidade com a distribuição original dos dadosm o melhor é usar essa redução mais para visualizar do que para aplicar métricas ou classificadores, e por isso também que nas notas onde uso distância euclidiana e similaridade de cossenos, ao reduzir as dimensões os resultados parecem errados ainda que nas dimensões originais esteja correto.</p>
<div class="notebook">
    <a class="notebook-link" href="http://nbviewer.jupyter.org/github/demacdolincoln/anotacoes-nlp/blob/src/files/SVD-PCA.ipynb">code</a>
</div>
</div>
    </div>
    </article>
</div>

        <nav class="postindexpager"><ul class="pager">
<li class="next">
                <a href="index-1.html" rel="next">Posts mais antigos</a>
            </li>
        </ul></nav><script>var disqus_shortname="demacdolincoln";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script></main><footer id="footer"><p>Contents © 2018         <a href="mailto:demacdolincoln@gmail.com">Lincoln de Macêdo</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>
    
    

    
    
    
</body>
</html>
